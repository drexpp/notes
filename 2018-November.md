November 2018
==========

Tech
----


### Go

  - Assign variables
```
// First option
var e int
e = 10
// e = 10

//Second option, in this case go infers the type of the variable
x := 3
x = 4
// x = 4

//This will print error
x := 1
x := 2
// COMPILER ERROR:
// no new variables on left side of :=
```

  - Function declaration
```  
func log(message string) {

}

func add(a int, b int) int {

}

func power(name string) (int, bool) {

}

_, exists := power("goku")
value, exists := power("goku")

//Short way if parameters are from same type
func add(a, b int) int {

}
```

### GraphQL
  - Introduction
    - Applications nowadays have the need to fetch data from a server where that data is stored in a database. It’s the responsibility of the API to provide an interface to the stored data that fits an application’s needs.
    - GraphQL is a query language for APIs - not databases.
    - GraphQL enables declarative data fetching where a client can specify exactly what data it needs from an API. Instead of multiple endpoints that return fixed data structures, a GraphQL server only exposes a single endpoint and responds with precisely the data a client asked for.
    
  - Problems solved
    - Overfetching: Downloading superfluous data
    - Underfetching and the n+1 problem: The client has to make additional requests to fetch everything it needs.
    
  - GraphQL SDL — Schema Definition Language
    - The main components of a schema definition are the types and their fields. Additional information can be provided as custom directives like the @default value specified for the likes field.
      - TYPE
        
        A type has a name and can implement one or more interfaces
        
        ```
        type Post implements Item {
          # ...
        }
        ```
      - INTERFACE
      
      In GraphQL an interface is a list of fields. A GraphQL type must have the same fields as all the interfaces it implements and all interface fields must be of the same type.
      
      ```
      interface Item {
        title: String!
      }
      ```
      
      - FIELD
      
      The GraphQL spec defines some built-in scalar values but more can be defined by a concrete implementation. The built in scalar types are:

          - Int
          - Float
          - String
          - Boolean
          - ID
          
      Non-nullable fields are denoted by an exclamation mark
      
      ```
      age: Int!
      ```
      
      Lists are denoted by square brackets
      
      ```
      names: [String!]
      ```
      
      An enum is a scalar value that has a specified set of possible values
      
      ```
      enum Category {
        PROGRAMMING_LANGUAGES,
        API_DESIGN
      }
      ```
      
      You can also express relationships just by adding the type of the extreme of the relationship
      
      ```
      type Post {
        title: String!
        author: Person!     #OneToOneRelationship
        comment: [Comments!] #OneToManyRelationship - 1 post ... n comments
      }
      ```
      
  -  Example of requests
  
      allPersons field in this query is called the root field of the query. Everything that follows the root field, is called the payload of the query. The only field that’s specified in this query’s payload is name.
  
      ```
      {
        allPersons {
          name
          age
        }
      }
      ```
  
      it returns 
    
      ```
      {
        "allPersons": [
          { "name": "Johnny",
            "age": 20       },
          { "name": "Sarah",
            "age": 17       },
          { "name": "Alice",
            "age": 32       }
        ]
      }
      ```
  
      You can use arguments inside queries so you can retrieve exactly what you need like "last" which returns only the number of elements specified

      ```
      {
        allPersons(last: 2) {
          name
        }
      }
      ```
  
  - Types of mutations in GraphQL
  
    - Creating new data
    - Updating existing data
    - Deleting existing data
    
    The mutation also has a root field - in this case it’s called createPerson
    
    One pattern you’ll often find is that GraphQL types have unique IDs that are generated by the server when new objects are created, you can access it by writing "id"
    
    ```
    mutation {
      createPerson(name: "Ivan", age: 23) {
        name
        age
      }
    }
    ```
    
  - Realtime updates with subscriptions
    
    When a client subscribes to an event, it will initiate and hold a steady connection to the server. Whenever that particular event then actually happens, the server pushes the corresponding data to the client. 
    
    Subscriptions represent a stream of data sent over to the client.
   
    After a client sent this subscription to a server, a connection is opened between them. Then, whenever a new mutation is performed that creates a new Person, the server sends the information about this person over to the client.
    ```
    subscription {
      newPerson {
        name
        age
      }
    }
    ```
  - Defining a basic schema
  
    A schema is simply a collection of GraphQL types. However, when writing the schema for an API, there are some special root types:
    
    ```
    type Query { ... }
    type Mutation { ... }
    type Subscription { ... }
    ```
    
    - To enable the allPersons-query that we saw before, the Query type would have to be written as follows
    
      ```
      type Query {
        allPersons(last: Int): [Person!]!
      }
      ```
      
      allPersons is called a root field of the API.
      
    - The createPerson-mutation, we’ll have to add a root field to the Mutation type
      
      ```
      type Mutation {
        createPerson(name: String!, age: Int!): Person!
      }
      ```
    -  For the subscriptions, we’d have to add the newPerson root field  
       
       ```
       type Subscription {
          newPerson: Person!
       }
       ```
       
    - Putting it all together the result of the schema would be
    
    ```
    type Query {
      allPersons(last: Int): [Person!]!
    }

    type Mutation {
      createPerson(name: String!, age: Int!): Person!
    }

    type Subscription {
      newPerson: Person!
    }

    type Person {
      name: String!
      age: Int!
      posts: [Post!]!
    }

    type Post {
      title: String!
      author: Person!
    }
    ```
    
 
