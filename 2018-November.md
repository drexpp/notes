November 2018
==========

Tech
----


### Go

  - Assign variables
```
// First option
var e int
e = 10
// e = 10

//Second option, in this case go infers the type of the variable
x := 3
x = 4
// x = 4

//This will print error
x := 1
x := 2
// COMPILER ERROR:
// no new variables on left side of :=
```

  - Function declaration
```  
func log(message string) {

}

func add(a int, b int) int {

}

func power(name string) (int, bool) {

}

_, exists := power("goku")
value, exists := power("goku")

//Short way if parameters are from same type
func add(a, b int) int {

}
```

### GraphQL
  - Introduction
    - Applications nowadays have the need to fetch data from a server where that data is stored in a database. It’s the responsibility of the API to provide an interface to the stored data that fits an application’s needs.
    - GraphQL is a query language for APIs - not databases.
    - GraphQL enables declarative data fetching where a client can specify exactly what data it needs from an API. Instead of multiple endpoints that return fixed data structures, a GraphQL server only exposes a single endpoint and responds with precisely the data a client asked for.
    
  - Problems solved
    - Overfetching: Downloading superfluous data
    - Underfetching and the n+1 problem: The client has to make additional requests to fetch everything it needs.
    
  - GraphQL SDL — Schema Definition Language
    - The main components of a schema definition are the types and their fields. Additional information can be provided as custom directives like the @default value specified for the likes field.
      - TYPE
        
        A type has a name and can implement one or more interfaces
        
        ```
        type Post implements Item {
          # ...
        }
        ```
      - INTERFACE
      
      In GraphQL an interface is a list of fields. A GraphQL type must have the same fields as all the interfaces it implements and all interface fields must be of the same type. Interfaces are useful to represent elements that might be of several types. [More information](https://docs.aws.amazon.com/appsync/latest/devguide/interfaces-and-unions.html)
      
      ```
      interface Item {
        title: String!
      }
      ```
      
      - FIELD
      
      The GraphQL spec defines some built-in scalar values but more can be defined by a concrete implementation. The built in scalar types are:

          - Int
          - Float
          - String
          - Boolean
          - ID
          
      Non-nullable fields are denoted by an exclamation mark
      
      ```
      age: Int!
      ```
      
      Lists are denoted by square brackets
      
      ```
      names: [String!]
      ```
      
      An enum is a scalar value that has a specified set of possible values
      
      ```
      enum Category {
        PROGRAMMING_LANGUAGES,
        API_DESIGN
      }
      ```
      
      You can also express relationships just by adding the type of the extreme of the relationship
      
      ```
      type Post {
        title: String!
        author: Person!     #OneToOneRelationship
        comment: [Comments!] #OneToManyRelationship - 1 post ... n comments
      }
      ```
      
  -  Example of requests
  
      allPersons field in this query is called the root field of the query. Everything that follows the root field, is called the payload of the query. The only field that’s specified in this query’s payload is name.
  
      ```
      {
        allPersons {
          name
          age
        }
      }
      ```
  
      it returns 
    
      ```
      {
        "allPersons": [
          { "name": "Johnny",
            "age": 20       },
          { "name": "Sarah",
            "age": 17       },
          { "name": "Alice",
            "age": 32       }
        ]
      }
      ```
  
      You can use arguments inside queries so you can retrieve exactly what you need like "last" which returns only the number of elements specified

      ```
      {
        allPersons(last: 2) {
          name
        }
      }
      ```
      Another example
      
      ```
      query {
        author(id: "abc") {
          posts {
            title
            content
          }
        }
      }
      ```
  
  - Types of mutations in GraphQL
  
    - Creating new data
    - Updating existing data
    - Deleting existing data
    
    The mutation also has a root field - in this case it’s called createPerson
    
    One pattern you’ll often find is that GraphQL types have unique IDs that are generated by the server when new objects are created, you can access it by writing "id"
    
    ```
    mutation {
      createPerson(name: "Ivan", age: 23) {
        name
        age
      }
    }
    ```
    
  - Realtime updates with subscriptions
    
    When a client subscribes to an event, it will initiate and hold a steady connection to the server. Whenever that particular event then actually happens, the server pushes the corresponding data to the client. 
    
    Subscriptions represent a stream of data sent over to the client.
   
    After a client sent this subscription to a server, a connection is opened between them. Then, whenever a new mutation is performed that creates a new Person, the server sends the information about this person over to the client.
    ```
    subscription {
      newPerson {
        name
        age
      }
    }
    ```
  - Defining a basic schema
  
    A schema is simply a collection of GraphQL types. However, when writing the schema for an API, there are some special root types:
    
    ```
    type Query { ... }
    type Mutation { ... }
    type Subscription { ... }
    ```
    
    - To enable the allPersons-query that we saw before, the Query type would have to be written as follows
    
      ```
      type Query {
        allPersons(last: Int): [Person!]!
      }
      ```
      
      allPersons is called a root field of the API.
      
    - The createPerson-mutation, we’ll have to add a root field to the Mutation type
      
      ```
      type Mutation {
        createPerson(name: String!, age: Int!): Person!
      }
      ```
    -  For the subscriptions, we’d have to add the newPerson root field  
       
       ```
       type Subscription {
          newPerson: Person!
       }
       ```
       
    - Putting it all together the result of the schema would be
    
    ```
    type Query {
      allPersons(last: Int): [Person!]!
    }

    type Mutation {
      createPerson(name: String!, age: Int!): Person!
    }

    type Subscription {
      newPerson: Person!
    }

    type Person {
      name: String!
      age: Int!
      posts: [Post!]!
    }

    type Post {
      title: String!
      author: Person!
    }
    ```
    
  - **Client**
  
    Infrastructure features that you probably want to have in your app:
    
    - **Directly sending queries and mutations without constructing HTTP requests**: When you previously used plain HTTP (like fetch in Javascript or NSURLSession on iOS) to load data from an API, all you need to do with GraphQL is write a query where you declare your data requirements and let the system take care of sending the request and handling the response for you. This is precisely what a GraphQL client will do.
    
    - **View Layer Integrations & UI updates**: Once the server response was received and handled by the GraphQL client, the requested data somehow needs to end up in your UI. Depending on the platforms and frameworks you’re developing with such as React or Vue.
    
    - **Caching Query Results**: GraphQL approach is to normalize the data beforehand. That means that the (potentially nested) query result gets flattened and the store will only contain individual records that can be referenced with a globally unique ID.
    
    - **Build-time Schema Validation**: When the build environment has access to the schema, it can essentially parse all the GraphQL code that’s located in the project and compare it against the information from the schema. This catches typos and other errors before an application gets into the hands of actual users.
    
    
  - **Server**:
    GraphQL implements resolvers to get the result of the query associated with each type (of the query), for example take this query
    
    - First let's define a Schema
    
      ```
      type Query {
        author(id: ID!): Author
      }

      type Author {
        posts: [Post]
      }

      type Post {
        title: String
        content: String
      }
      ```
    - Build a query
    
      ```
      query {
        author(id: "abc") {
          posts {
            title
            content
          }
        }
      }
      ```
    - This query has types related to each field
    
      ```
      query: Query {
        author(id: "abc"): Author {
          posts: [Post] {
            title: String
            content: String
          }
        }
      }
      ```
    - The resolvers will be found in our servers to proccess the query, the execution starts at the query type and goes breadth-first. This means we run the resolver for *Query.author* first. Then, we take the result of that resolver, and pass it into its child, the resolver for *Author.posts*. At the next level, the result is a list, so in that case, the execution algorithm runs on one item at a time. At the end, the execution algorithm puts everything together into the correct shape for the result and returns that.
    
      ```
      Query.author(root, { id: 'abc' }, context) -> author
      Author.posts(author, null, context) -> posts
      for each post in posts
        Post.title(post, null, context) -> title
        Post.content(post, null, context) -> content
      ```
    
  - More concepts
  
    - **Enhancing Reusability with Fragments**: *Fragments* are a handy feature to help to improve the structure and reusability of your GraphQL code. A fragment is a collection of fields on a specific type
    
      Starting type
      
      ```
      type User {
        name: String!
        age: Int!
        email: String!
        street: String!
        zipcode: String!
        city: String!
      }
      ```
    
      We could represent all the information that relates to the user’s physical address into a fragment:
      
      ```
      fragment addressDetails on User {
        name
        street
        zipcode
        city
      }
      ```
      
      And then reuse it as follows
      
      ```
      {
        allUsers {
          ... addressDetails
        }
      }
      ```
      
      Which would be equivalent to writing the following query
      
      ```
      {
        allUsers {
          name
          street
          zipcode
          city
        }
      }
      ```
      
### Numpy

  - Arrays
    - The central feature of NumPy is the array object class. Arrays are similar to lists in Python,
except that every element of an array must be of the same type

      Creating a simple array
      
        ```
        a = np.array([1, 2, 3, 4], float)
        ```
	   
	    You can use slices just as in python notation, it excludes right term.
      
        ```
        a[:2]   returns array([1., 2.])
        a[:]    returns array([1., 2., 3., 4.])
        a[::-1] returns array([4., 3., 2., 1.])
        ```
        
  - Arrays can be multidimensional, **different axes are accessed using commas inside bracket notation**.
  
    ```
    a = np.array([[1, 2, 3], [4, 5, 6]], float)
    
    a.shape     returns (2, 3), meaning 2 rows, 3 colums
    a.dtype     returns the type of values stored in the array, dtype('float64'), double-precision (8-byte) real number
    
    a[0, 0]     here is trying to access array index 0, position 0, returning 1.0
    a[1, 2]     array index 1, position 2, returning 6.0
    ```
    
    Slicing still works 
    
    ```
    a[:, :]     take all rows and take all columns, returns array([[1., 2., 3.], [4., 5., 6.]])
    
    Remember a.shape => (2, 3)
    
    a[:, :-1]   take all rows, and take from column start to length_columns(3) - 1 = 2, equivalent a[0:2, 0:2] returns array([[1., 2.],
       [4., 5.]])
      
    a[:-1, :-2] take, length_rows(2) - 1 = 1, and length_columns(3) - 2 = 1, same as a[0:1, 0:1] returns array([[1.]])
    ```
    
    - Useful utilities
    
      - Length
        ```
        len(a)    returns the length of the first axis, rows = 2.
        ```
        
      - Testing if a value is present
        ```
        2 in a    returns True
        0 in a    returns False
        ```
        
      - Reshape, arrays can be reshaped using tuples that specify new dimensions. Reshape creates a new array and does not modify the original array 
        ```
        a = np.array(range(10), float)    returns array([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])
        a = a.reshape((5, 2))             returns array([[ 0., 1.], [ 2., 3.],[ 4., 5.],[ 6., 7.],[ 8., 9.]])
        a.shape                           returns (5, 2)
        ```
        
      - Copy function, it can be used to create a new, separate copy of an array in memory if needed
      ```
       a = np.array([1, 2, 3], float)
       b = a                                They are the same, they just reference to the same memory address
       c = a.copy()                         c is a new copy of a but in different memory address which means they are independent
       
       a[0] = 0                             a and b will be equal, array([0., 2., 3.]) but c will keep its values as array([1., 2., 3.])
      ```
  
      - List can also be created from arrays
        ```
        a.tolist()                            returns [1.0, 2.0, 3.0]
        list(a)                               returns [1.0, 2.0, 3.0]
        ```
    
      - One can convert arrays to binary strings (non-human readable) using tostring(), this function allow arrays to be reconverted from raw data later on. It is convenient for saving large amount of array data in files.
        ```
        a = array([1, 2, 3], float)
        s = a.tostring()                returns '\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@'
        np.fromstring(s)                returns array([1., 2., 3.])
        ```
        
      
      
    
    
    
    
    
    
